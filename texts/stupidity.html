<!DOCTYPE html>
<html lang="pt-BR" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="">
    <meta name="keywords" content="formatação, windows, linux, freebsd, bios, uefi, instalação, balena, etcher, ventoy, os">
    <meta name="author" content="Cain">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WinStupid</title>
    <!--Social Media Open Graph-->
    <meta property="og:title" content="Escória de indústria da computação"/>
    <meta property="og:url" content="https://cain-dev.github.io/default/"/>
    <meta property="og:type" content="article"/>
    <meta property="og:description" content="Entenda por que o Windows causa estupidez - Texto de Matthew D. Fuller"/>
    <meta property="og:image" content="https://raw.githubusercontent.com/cain-dev/default/main/assets/images/ogimage.jpg"/>
    <!--/Social Media Open Graph-->
    <!--Links-->
    <link rel="shortcut icon" href="../assets/images/cainlogo.ico">
    <link rel="stylesheet" type="text/css"href="../os_style.css">   
    <!--/Links-->
</head>
<body>
    <header id="main-header">
        <ul>
            <li><a href="../index.html">Home</a></li>
            <li><p>@cain-dev</p></li>
            <li><a href="../extra/contact.html">Contato</a></li>
        </ul>
    </header>
    <main id="main-area">
        <h1>Por que o Windows causa estupidez</h1>
        <p>Este é apenas uma tradução de um texto do Matthew D. Fuller, todos os créditos vão para ele.<br>(https://www.over-yonder.net/~fullermd/rants/winstupid/1) </p>
        <h2>Escória da Indústria da Computação</h2>
        <p>Microsoft. Todos nós a conhecemos. Muitos de nós a odiamos. Todos nós podemos dar razões, é claro; algumas técnicas, algumas filosóficas, algumas econômicas, algumas morais, algumas puramente emocionais.</p>
        <p>Claro, é um caso difícil. Muitas pessoas simplesmente ficam presas no “Sim, mas eles estão ganhando dinheiro”, e param de ouvir nesse ponto. Outras pessoas nem chegam tão longe, e ficam com “Eles são populares”, ou até mesmo o temido “Eles tornaram possível para qualquer um usar um computador”, ou outras frases de efeito que tendem a descarrilar argumentos reais. E não é porque são pontos válidos, é porque são praticamente impossíveis de abordar; são pontos perfeitamente válidos, mas em um contexto totalmente diferente do que os argumentos estão inseridos.</p>
        <h2>Por onde começar?</h2>
        <p>Então, estou começando do zero. Estou fazendo a seguinte afirmação:</p>
        <blockquote>O Windows atrasou significativamente a indústria de TI e continua a fazê-lo. O Windows incentiva, recompensa e praticamente exige estupidez por parte de seus usuários, e ainda tenta forçar tal comportamento em qualquer pessoa que tenha que lidar com os usuários.</blockquote>
        <p>Eu não me importo com o que você pensa deles como um negócio; todo mundo e sua mãe, incluindo eu, concordarão que eles estão fazendo um ótimo trabalho ao administrar um negócio. Se você achar necessário considerar a estupidez declarada como um insulto, você pode muito bem parar por aqui. Não é um insulto. É uma afirmação.</p>
        <h2>Estupidez não é um insulto.</h2>
        <p>Se você não sabe algo, você é estúpido sobre esse algo. Eu sou bastante estúpido sobre engenharia automotiva. Eu sou bastante estúpido sobre fabricação de plexiglass, criação de animais, agricultura e bioquímica. Se você não entende de computadores, você é estúpido sobre computadores. Você não é bem “analfabeto em computação”. É uma frase de desculpa, e a única razão para usar uma frase de desculpa é tentar enganar outras pessoas e/ou a si mesmo. Admita; você é estúpido sobre computadores. Não é um estigma, é uma admissão, e é uma coisa positiva. Significa “Eu não sei isso”, que não deveria ser visto como um negativo, mas como um positivo. Não é um vazio, é um vazio pronto para ser preenchido com conhecimento.</p>
        <h2>OK, sou estúpido. E agora?</h2>
        <p>Bem, é sobre isso que este desabafo é. Isso não é “Como usar computadores”. Isso não é uma instrução para curar essa estupidez. O que vou fazer é explicar como a Microsoft em geral e o Windows em particular estão incentivando e espalhando a estupidez que infestou esta indústria.</p>
        <p>Também vou generalizar um pouco e falar sobre alguns conceitos gerais, como “facilidade de uso”, e tentar explicar as maneiras pelas quais eles podem ser expandidos para realmente nos servir, as pessoas, em vez do contrário. Para um tratamento mais aprofundado da facilidade de uso, veja meu desabafo sobre O Que Significa Ser Fácil de Usar.</p>
        <h2>Para frente e para cima</h2>
        <p>Então, por onde começar? Na verdade, há uma ampla gama de tópicos gerais em questão aqui. Há muita teoria da aprendizagem e psicologia comportamental. Eu não sou um psicólogo comportamental; estou apenas observando o que está acontecendo na indústria de TI com constante alarme.</p>
        <h1>Curvas de aprendizagem</h1>
        <h2>Elenco</h2>
        <p>Vamos colocar alguns jogadores no tabuleiro. Os conceitos subjacentes ao Unix™ e aqueles subjacentes ao Windows são opostos diametralmente, então eles são antagonistas naturais nesta discussão. Eu não vou entrar em detalhes, exceto quando necessário para ilustrar um ponto. Eu não estou tentando (neste desabafo, de qualquer maneira) convencer você de que o Unix é melhor. Certamente não vou entrar nas constantes guerras religiosas entre os vários sabores do Unix. Estou usando o Unix, não como um sistema operacional, mas como uma abordagem para sistemas operacionais.</p>
        <h2>As diferenças essenciais</h2>
        <p>As diferenças entre a Filosofia Unix e a Filosofia Windows são vastas, é claro. Mas muitas delas podem ser resumidas em uma questão de inteligência, e é isso que vamos abordar aqui. Unix e Windows armazenam a inteligência em lugares diferentes. Unix armazena a inteligência no usuário; Windows armazena a inteligência no sistema operacional. Parece uma diferença pequena e simples por si só, mas quanto mais você olha, maior ela fica até se tornar um enorme abismo.</p>
        <p>Dessa aparente simples dicotomia, grandes partes da filosofia de ambos naturalmente seguem. Mais cedo ou mais tarde, você percebe que, em vez de ser uma pequena diferença de posicionamento de opinião, essa simples distinção é, de fato, uma das, senão a, diferença central entre as abordagens para o design de sistemas operacionais.</p>
        <h2>Curvas de aprendizagem</h2>
        <p>Entra o conceito da ‘Curva de Aprendizado’. A maioria das pessoas tem pelo menos uma compreensão básica do conceito, mas para aqueles que não têm, aqui está um resumo rápido.</p>
        <p>A curva de aprendizado de (algo) é uma medida da taxa na qual você aprende, ou é necessário aprender, sobre isso. Uma ‘curva de aprendizado íngreme’ geralmente se refere a algo que requer muito aprendizado inicial. Uma ‘curva de aprendizado suave’ é exatamente o oposto; um aprendizado muito suave significa, ao invés de uma necessidade de estudo intensivo.</p>
        <p>Armado com essas definições, é bastante simples dizer que o Unix tem uma curva de aprendizado inerentemente íngreme, e o Windows tem uma muito suave. Isso não é uma nova observação para muitas pessoas, mas codificá-la assim nos dá um quadro de referência.</p>
        <h2>Para elaborar...</h2>
        <h3>Windows</h3>
        <p>Nossos irmãos da Microsoft adotaram a abordagem de criar a curva de aprendizado mais suave possível. Para pegar uma dica da indústria de fast food, o Windows é o brinquedo ‘para menores de 3 anos’ do mundo dos sistemas operacionais. O objetivo final é destruir completamente qualquer barreira de entrada, removendo qualquer requisito de conhecimento inicial ou aprendizado de como e por que, e tornando o sistema simples o suficiente para que possa ser usado sem qualquer entendimento de como funciona.</p>
        <h3>Unix</h3>
        <p>O grupo Unix adotou a abordagem oposta. O Unix tem uma curva de aprendizado íngreme; não protege o usuário da complexidade; ao contrário, ele se deleita na complexidade. Reconhece que um computador de uso geral é um dispositivo diabolicamente complicado capaz de fazer uma variedade inacreditável de coisas. Reconhece que o computador é uma ferramenta do usuário e, portanto, adota uma filosofia de construção de ferramentas. Faça muitas ferramentas, e faça cada ferramenta específica, e deixe o usuário selecionar a ferramenta que acha apropriada, e deixe o usuário combinar as ferramentas como quiser. Não visa tornar as coisas fáceis; visa tornar as coisas possíveis.</p>
        <h2>Já chegamos?</h2>
        <p>Agora, essas linhas de batalha devem soar familiares. Correndo o risco de parecer partidário (o que eu sou), vou me arriscar e fazer a afirmação ousada de que o grupo Unix entende o grupo Windows muito melhor do que o grupo Windows entende o grupo Unix. E eu não acho que isso seja um grande exagero; olhe para as filosofias básicas. A filosofia Unix é baseada em um entendimento completo; a filosofia do Windows é baseada em simplicidade completa. Ambos os lados olham para o outro com desprezo, é claro; ambos acreditam que o outro é inferior. Mas o lado Unix se esforça para aprofundar, enquanto o lado Windows se esforça para rasear (estou bem ciente de que ‘rasear’ não é uma palavra. Deveria ser.)</p>
        <h2>OK, então onde está o “lá”, afinal?</h2>
        <p>Agora, vamos olhar para os efeitos dessa diferença nas curvas de aprendizado. Existem dois efeitos principais; um deles é psicológico, no usuário, e o outro é tecnológico, no sistema.</p>
        <h1>Curvas de aprendizagem e usuários</h1>
        <h2>Melhoria</h2>
        <p>Suposição básica: Melhoria é bom. Mais é preferível a menos. Quer dizer, vamos lá, pessoal; realmente não há muita coisa na vida que seja mais divertida do que aprender, do que de repente entender algo que você não entendia antes. E mesmo além disso, aprender mais quase invariavelmente permite que você faça as coisas melhor e mais rápido. Abre novas portas para entender como algo é feito, e até mesmo permite que você descubra novas coisas que você nem sabia que existiam.</p>
        <h2>Mo-ti-va-ção!</h2>
        <p>O problema, então, é uma questão de motivação. É quase impossível aprender se você não está motivado para fazê-lo. E é quase impossível deixar de aprender se você está motivado para isso. Todo professor sabe disso; tentar ensinar alguém que não se importa é uma tarefa dolorosa, mas quando você tem um aluno que se importa, você tem que trabalhar duro para manter as informações fluindo para eles tão rápido quanto eles estão absorvendo. E esses são os que tornam todo o processo de ensino gratificante.</p>
        <p>Não é divertido nem produtivo tentar enfiar conhecimento goela abaixo em gargantas relutantes. O verdadeiro desafio do ensino é motivar seus alunos a aprender.</p>
        <h2>Entre na curva</h2>
        <p>Agora, vamos aplicar as curvas de aprendizado a isso. Para fazer uso de um sistema Unix, você tem que subir uma curva íngreme. Há um pouco de trabalho inicial e conhecimento que você tem que colocar para adquirir apenas um nível básico de proficiência nele. Leva algum investimento de tempo para chegar ao ponto em que você pode fazer mais do que apenas olhar para ele. Então, até o momento em que alguém tem um conhecimento prático do Unix, eles já investiram um bom esforço nisso.</p>
        <p>Em contraste, a curva de aprendizado rasa do Windows permite uma integração muito rápida e fácil. Uma pessoa pode adquirir um conhecimento prático do Windows em uma hora. Não requer nenhum estudo, ou muita questionamento. Para todos os efeitos práticos, é quase indistinguível de nenhum investimento.</p>
        <h2>A psicologia comportamental mostra sua cara feia</h2>
        <p>Todos os psicólogos amadores, reúnam-se. Eu faço a vocês uma simples pergunta. Dados esses dois usuários, um dos quais investiu tempo e esforço para adquirir conhecimento em Unix, e um dos quais não investiu nada para adquirir conhecimento em Windows, qual deles terá a motivação e a inclinação para seguir em frente e continuar aprendendo?</p>
        <p>E essa é a questão crucial, não é? Uma pessoa fica com a impressão de que “Eu não preciso aprender nada, o computador faz isso por mim”, e assim não tem motivo para acreditar que aprender mais melhorará sua experiência. Afinal, eles não precisaram aprender nada para chegar até aqui. E além da impressão da utilidade do aprendizado, há a questão do investimento; ele não investiu nada no projeto de usar o computador, então ele tem muito menos motivação para investir mais. Você sempre está menos comprometido em melhorar algo que alcançou de passagem, do que algo em que já investiu esforço.</p>
        <p>Nossa pessoa do Unix, por outro lado, naturalmente tem a impressão de que “Eu posso fazer X, Y e Z com o que já aprendi; eu me pergunto o que serei capaz de fazer com o próximo lote de coisas que vou aprender?” Agora essa é a atitude do “Bom Aluno”! Eles já reconhecem que o aprendizado lhes deu uma recompensa tangível, e eles têm uma excitação natural (mais pronunciada em alguns do que em outros, é claro) para qual joia será revelada a eles em seguida. Além disso, como mencionado acima, eles já investiram neste evento, o que os torna muito mais inclinados a investir mais.</p>
        <p>E, muito em breve, eles percebem que “usar computadores” não é algo que você aprende e faz; é algo que você aprende e aprende mais. Não é um item, é um campo. Existem praticamente incontáveis níveis de facilidade que você pode ter nele. Tentar dizer que existem apenas duas categorias, aquelas de “Pode” e “Não pode” é um dos maiores desserviços que você pode fazer ao reino do uso do computador.</p>
        <p>Quanto mais você aprende, mais você percebe que há para ser aprendido. Para aqueles que aprenderam praticamente nada, eles muitas vezes nem mesmo percebem que HÁ mais para ser aprendido, para não falar de ter qualquer inclinação para aprender.</p>
        <h2>Para o próximo nível</h2>
        <p>Agora, vamos examinar os efeitos das curvas de aprendizado nos sistemas.</p>
        <h1>Curvas de aprendizagem e Sistemas</h1>
        <h2>Sistemas também são pessoas, 'cê sabe</h2>
        <p>Estabelecemos que a inclinação da curva de aprendizado pode ter um efeito profundo nas potencialidades futuras de um usuário. Mas também pode afetar o próprio sistema. Afinal, nada existe no vácuo; você não pode mudar parte do comportamento de um sistema sem que isso tenha efeitos em cascata em todo o sistema.</p>
        <h2>Simplicidade</h2>
        <p>Vamos dar uma olhada em como o Windows achatou a curva de aprendizado. Você se depara com várias coisas na sua vida diária que têm opções ‘avançadas’. Motores de busca na web. Formulários de imposto de renda. O que os torna ‘avançados’? Bem, eles têm mais opções! ‘Avançado’ é realmente um eufemismo para ‘mais poderoso’. Isso é bastante compreendido…</p>
        <p>Agora, aqui está a parte divertida. Vamos inverter isso. ‘Simples’ e ‘simplificado’ realmente significam o mesmo que ‘simplista’, que pode ser traduzido livremente para ‘menos poderoso’. E, ainda mais, como ‘menos flexível’ e ‘menos configurável’. De repente, a revelação nos atinge nas maçãs do rosto.</p>
        <h2>Simples significa Limitado</h2>
        <p>BAM, como um tiro. Lembra-se da última seção onde eu disse que “aprender mais quase invariavelmente permite que você faça as coisas melhor e mais rápido”? Bem, bem-vindo ao motivo pelo qual é “quase”. Não ajuda quando você está em um sistema inerentemente limitado. Há um teto duro; há um certo nível que você simplesmente não pode ultrapassar, porque não há ferramentas além dele, e não há como avançar mais. Então, por que diabos você deveria se incomodar em continuar aprendendo, quando isso não vai te trazer nada?</p>
        <p>A conclusão? Falhar em avançar seu conhecimento em um sistema seguindo a Filosofia Unix colocará você em uma grande e crescente desvantagem em relação àqueles que o fazem. Mas falhar em fazer esse impulso em um sistema sob a Filosofia Windows realmente não fará, porque há um teto infinitamente mais baixo até onde você pode ir.</p>
        <p>O Windows alcança sua simplicidade inerente removendo opções. E fez isso tão habilmente que, a menos que você tenha experiência com outros sistemas, você nunca percebe a falta. Ao remover opções, claro, você torna mais rápido e fácil de aprender; há menos para aprender. Ao remover opções flexíveis e poderosas, como linhas de comando e pipes, você corta muito do aprendizado. Ao apresentar grandes ferramentas integradas de múltiplos propósitos, você torna muito mais rápido aprender uma determinada tarefa, mas você corta a flexibilidade infinitamente maior de pequenas ferramentas de único propósito com um meio de conectá-las.</p>
        <h2>O teto</h2>
        <p>E, você elimina a maneira mais eficaz de os usuários trabalharem. Cada pessoa é diferente. Cada pessoa pensa de maneiras diferentes. Nós agimos, reagimos, examinamos, aprendemos e trabalhamos de maneiras diferentes. Com ferramentas de propósito único discretas, com boa isolação e interfaces bem definidas, você pode moldar tudo exatamente da maneira que você trabalha. Minha área de trabalho, por exemplo, é praticamente perfeita para a maneira como eu trabalho e penso; para muitas pessoas, seria totalmente contra-intuitivo. Por causa do meu sistema, tenho a flexibilidade de fazer quase qualquer mudança que eu quiser.</p>
        <p>Com um sistema projetado em torno de ferramentas monolíticas independentes, você está severamente limitado em quanto pode mudar. Afinal, as ferramentas não foram projetadas para serem alteradas. Elas foram projetadas para funcionar e parecer de uma certa maneira. E foram projetadas para serem itens específicos em uma determinada estrutura, em vez de “caixas pretas” independentes que podem ser substituídas por outras de maneira contínua. Afinal, é uma filosofia muito mais simples de se trabalhar, já que você não precisa aprender sobre todas as opções potenciais, ou tirar um tempo para olhá-las e decidir qual é a melhor para você. Você apenas tem que viver com o que alguém decidiu que era o melhor.</p>
        <h2>Monomania</h2>
        <p>Para toda a propaganda de “Para onde você quer ir hoje?”, podemos ver que a Filosofia do Windows realmente se resume a deixar alguém lhe dizer Como As Coisas Serão. A Filosofia Unix é sobre fornecer ferramentas e os meios para usá-las, permitindo então que cada pessoa as use da maneira que melhor lhes convier. Uma das citações mais comuns sobre o Unix é “Unix não impede você de fazer coisas estúpidas, porque isso também impediria você de fazer coisas inteligentes.” E é verdade; qualquer redução na escolha é uma redução na escolha.</p>
        <h2>Ajuda! Resumo!</h2>
        <p>Chega de tagarelar. Vamos tentar resumir. Avante, para Por que é importante.</p>
        <h1>Por que isso importa</h1>
        <h2>Mas isso importa?</h2>
        <p>Sim, importa.</p>
        <p>A única vez que isso não importa é se você adotar uma visão extremamente de curto prazo. As empresas americanas são, claro, famosas por fazer isso; lucros de curto prazo significam mais do que estabilidade de longo prazo. E isso está implícito na mentalidade americana de “Eu Quero o Meu Agora”. Mas não é uma estratégia frutífera a longo prazo.</p>
        <p>Em todas as outras atividades, é implícito e dado como certo que quanto mais tempo você faz algo, melhor você se torna nisso, essencialmente sem fim. Em outras palavras, uma escala infinita de realização. E presume-se que um nível básico de competência deve ser alcançado antes que você possa realisticamente fazer qualquer coisa no campo. Você faz um esforço e ganha facilidade. Você faz um esforço e ganha facilidade. Você faz um esforço e ganha facilidade. E isso continua e continua. Por que se presume que os computadores são diferentes?</p>
        <h2>Computadores não são eletrodomésticos</h2>
        <p>E eles provavelmente não estarão no futuro próximo. Poderia ser argumentado que eles também não deveriam estar.</p>
        <p>Já temos computadores de eletrodomésticos. Seu carro provavelmente tem um. Seu micro-ondas tem um microcontrolador. Aquele cachorrinho mecânico que você deu para o seu filho de 6 anos no Natal, que anda, late e abana o rabo, tem um computador nele. Seu aparelho de som, sua TV, sua secretária eletrônica. Você está cercado por dispositivos de computação de propósito específico, e esses são eletrodomésticos. Eles são totalmente projetados em torno das necessidades desse propósito e são tão especificamente direcionados que não requerem muito conhecimento para funcionar.</p>
        <h2>Mas estamos falando de computadores de uso geral</h2>
        <p>Ele pode rodar jogos. Ele pode tocar música. Ele pode reproduzir filmes. Ele pode calcular o valor de pi para qualquer número de casas decimais que você pedir. Ele pode escrever e-mails. Ele pode pesquisar milhares de páginas de texto. Não é uma máquina de propósito específico.</p>
        <p>Os computadores de propósito geral na verdade não fazem nenhuma dessas tarefas. Seu propósito inteiro é ser de propósito geral. Tudo o que eles fazem é aceitar instruções, em uma linguagem especificamente projetada para ser o mais geral possível. Um computador de propósito geral tem um conjunto específico de operações básicas que podem ser combinadas de qualquer maneira. Agora, a maioria das pessoas só usa conjuntos de instruções (vamos chamá-las de “programas”, porque é isso que são) que outras pessoas pré-escreveram para um propósito específico. Mas isso não muda a ideia base.</p>
        <h2>Há mais coisas no céu e na terra...</h2>
        <p>Um computador de propósito específico tem um conjunto específico (e pequeno) de possíveis entradas e um conjunto específico (e pequeno) de possíveis saídas. Um computador de propósito geral tem um conjunto enorme (praticamente infinito) de possíveis entradas e um conjunto de saídas de tamanho semelhante. Qualquer coisa pode ser manipulada de quase infinitas maneiras. Você não pode tornar isso trivial, e quanto mais você tenta, mais você consegue fazer nada além de destruir o próprio poder e flexibilidade que o trouxe aos computadores em primeiro lugar.</p>
        <h2>Computadores são difíceis</h2>
        <p>Aceite isso. Siga em frente. Sua vida será muito mais simples.</p>
        <p>Aceite que vai dar trabalho. Aceite que vai exigir aprendizado. Aceite que vai envolver tentativa e erro. Aceite que vai significar apenas aceitar coisas sem entender o porquê até mais adiante. Uma vez que você faça isso, descobrirá que aprender tecnologia da computação não é como abrir um envelope e ver o que há dentro; é como assistir a uma rosa se abrir, pétala por pétala… e não importa quanto tempo você observe, sempre haverá outra pétala com outra camada de beleza sob ela.</p>
        <h2>Fim?</h2>
        <p>Por enquanto.</p>
    </main>
    <footer id="main-footer">
        <p>Está página ainda está em construção 🚧</p>
        <a class="footerlink" href="#main-header">↑ Retornar ao topo ↑</a>
    </footer>
</body>
</html>